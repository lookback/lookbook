#!/usr/bin/env bash
set -eo pipefail

# Script to perform multiple find and replace operations on files or all files in a directory
# Usage: ./scripts/find-replace [options] <file_or_directory>
# Options:
#   -m, --mappings <file>    Mappings file (default: mappings.txt)

# Default values
MAPPINGS_FILE="mappings.txt"
TARGET_PATH=""

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -m|--mappings)
            MAPPINGS_FILE="$2"
            shift 2
            ;;
        -h|--help)
            echo "Usage: $0 [options] <file_or_directory>"
            echo ""
            echo "Options:"
            echo "  -m, --mappings <file>    Mappings file (default: mappings.txt)"
            echo "  -h, --help              Show this help message"
            echo ""
            echo "Examples:"
            echo "  $0 src/lookbook.css"
            echo "  $0 -m my-mappings.txt src/"
            echo "  $0 --mappings custom.txt src/components/"
            exit 0
            ;;
        -*)
            echo "Error: Unknown option $1"
            echo "Use -h or --help for usage information"
            exit 1
            ;;
        *)
            if [[ -z "$TARGET_PATH" ]]; then
                TARGET_PATH="$1"
            else
                echo "Error: Multiple target paths specified. Only one file or directory allowed."
                exit 1
            fi
            shift
            ;;
    esac
done

# Check if target path is provided
if [[ -z "$TARGET_PATH" ]]; then
    echo "Error: Target file or directory is required"
    echo "Usage: $0 [options] <file_or_directory>"
    echo "Use -h or --help for usage information"
    exit 1
fi

# Check if target path exists
if [[ ! -e "$TARGET_PATH" ]]; then
    echo "Error: Target path '$TARGET_PATH' does not exist"
    exit 1
fi

# Check if mappings file exists
if [[ ! -f "$MAPPINGS_FILE" ]]; then
    echo "Error: Mappings file '$MAPPINGS_FILE' does not exist"
    echo "Please create a mappings file with the format:"
    echo "find_pattern=replace_pattern"
    echo "Example:"
    echo "text-f1=text-xm"
    echo "theme(spacing.2)=var(--spacing-2)"
    exit 1
fi

# Determine if target is a file or directory and build file list
FILES_TO_PROCESS=()

if [[ -f "$TARGET_PATH" ]]; then
    # Single file
    FILES_TO_PROCESS+=("$TARGET_PATH")
    echo "Processing single file: $TARGET_PATH"
elif [[ -d "$TARGET_PATH" ]]; then
    # Directory - find all files (excluding the mappings file itself)
    while IFS= read -r -d '' file; do
        # Skip the mappings file
        if [[ "$(basename "$file")" != "$(basename "$MAPPINGS_FILE")" ]]; then
            FILES_TO_PROCESS+=("$file")
        fi
    done < <(find "$TARGET_PATH" -type f -print0 2>/dev/null)
    
    # Check if any files were found
    if [[ ${#FILES_TO_PROCESS[@]} -eq 0 ]]; then
        echo "No files found in directory '$TARGET_PATH'"
        exit 0
    fi
    
    echo "Found ${#FILES_TO_PROCESS[@]} files to process in '$TARGET_PATH'"
else
    echo "Error: '$TARGET_PATH' is neither a file nor a directory"
    exit 1
fi

# Process each file
for target_file in "${FILES_TO_PROCESS[@]}"; do
    echo ""
    echo "Processing: $target_file"
    
    # Process each mapping for this file
    echo "Applying mappings from $MAPPINGS_FILE..."
    while IFS='' read -r line; do
        # Skip empty lines and comments
        [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
        
        # Remove leading/trailing whitespace
        line=$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        
        # Skip if line is empty after trimming
        [[ -z "$line" ]] && continue
        
        # Check if line contains = delimiter
        if [[ "$line" == *"="* ]]; then
            IFS='=' read -r find_pattern replace_pattern <<< "$line"
        else
            echo "Warning: Skipping line without = delimiter: '$line'"
            continue
        fi
        
        # Remove leading/trailing whitespace from patterns
        find_pattern=$(echo "$find_pattern" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        replace_pattern=$(echo "$replace_pattern" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        
        # Skip if pattern is empty after trimming
        [[ -z "$find_pattern" ]] && continue
        
        echo "  Replacing: '$find_pattern' -> '$replace_pattern'"
        
        # Escape special characters in find_pattern for sed (including parentheses)
        escaped_find_pattern=$(echo "$find_pattern" | sed 's/[|\\.*^$()+?{}[\]]/\\&/g')

        # Escape & in the replacement string for sed
        escaped_replace_pattern=$(echo "$replace_pattern" | sed 's/&/\\&/g')

        # Use | as the delimiter in sed to avoid issues with /
        sed -i '' "s|$escaped_find_pattern|$escaped_replace_pattern|g" "$target_file"
        
    done < "$MAPPINGS_FILE"
    
    echo "Completed processing: $target_file"
done

echo ""
echo "Find and replace operations completed successfully!"
echo "Processed ${#FILES_TO_PROCESS[@]} file(s)" 
